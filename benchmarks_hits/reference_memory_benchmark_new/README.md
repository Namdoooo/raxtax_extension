# Benchmark: Reference Count vs Memory

## Purpose
This benchmark evaluates how the peak memory usage of the extended
raxtax workflow scales with an increasing number of reference sequences.
The objective is to assess the impact of reference count on memory usage.

## Benchmark Design
The benchmark is organized into multiple independent iterations.
Within each iteration, the number of references is varied between 400 and
3200 while all other parameters remain fixed.

For each test within an iteration, a new dataset is generated using
different random seeds. In total, five iterations are performed.
Peak memory usage is measured to evaluate memory scalability.

## Data Generation
All input data used in this benchmark is generated automatically by the
benchmark scripts. No external input data is required.

For each test, a new dataset is generated using random seeds. Both the
query sequences and the corresponding reference data are regenerated
for each reference count.

## Execution workflow
The benchmark execution is organized in multiple layers.

The `main.py` file in the benchmark root directory orchestrates the
execution of all iterations. For each iteration, it invokes the
corresponding `main.py` located in the iteration subdirectory.

The `main.py` file inside each iteration directory is identical across
all iterations and is responsible for executing all tests within that
iteration. For each iteration, the required directory structure for the
individual tests is created automatically.

For each test, the iteration-level `main.py` performs the following
steps:

1. Generates a configuration file and an executable to run the
   simulation.
2. Executes the simulation using the generated executable and
   configuration file.
3. Generates the input data based on the configuration file.
4. Executes the classification algorithm (raxtax extension) on the
   generated input data.

## How to Run
From the raxtax root directory, execute

```
python -m benchmarks_hits.reference_memory_benchmark_new.main
```

After completion, analysis and plotting can be performed with:

```
python -m benchmarks_hits.reference_memory_benchmark_new.analyze
```

## Output

### Per test (within each iteration)
For each test run, the following directories and files are generated:

- `queries/`  
  Contains the generated query sequences used as input for the
  classification algorithm. This directory also includes intermediate
  files and log files produced during query generation.
- `references/`  
  Contains the generated reference data used for classification. This
  directory also includes intermediate files, log files, and a lookup
  table required by the classification algorithm.
- `results_*/`  
  Contains the classification results and a `metadata.out` file containing
  runtime measurements and classification statistics.
- `psutil_memory_results.csv`  
  Contains memory usage measurements recorded during execution.

For archival purposes, the `queries/` and `references/` directories
generated by the benchmark were manually zipped together as
`dataset.tgz` to reduce storage requirements.

### After analysis
After executing the analysis script (`analyze.py`), the following
additional output files are generated:

- `aggregated_memory_data.csv`  
  Aggregated memory data for all tests within a single iteration.
- `combined_memory_data.csv`  
  Aggregated memory data across all iterations.
- `plots/`  
  Directory containing generated plots.
- `leaf_count_vs_memory.pdf`  
  Final plot showing the relationship between reference count and memory.

## Notes
The benchmark was executed using commit `749825ba35a9c5fa32340b378c74566cfa2bd507` of the `raxtax_extension`
repository.